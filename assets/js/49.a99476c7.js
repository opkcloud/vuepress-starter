(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{461:function(e,n,r){"use strict";r.r(n);var t=r(2),a=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h5",{attrs:{id:"pika"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pika"}},[e._v("#")]),e._v(" pika")]),e._v(" "),n("p",[e._v("pika是一款基于rocksdb可持久化兼容redis协议的kv存储。当前最新的特性中还支持codis，可作为codis的后端存储使用，但是运维命令稍微有些不同。pika相对于redis而言主要是适合在容量大的场景下，简化了数据加载和迁移的相关操作，但是整体基于硬盘或者"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=SSD&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[e._v("SSD"),n("OutboundLink")],1),e._v("的存储响应性能可能会差些。不过本文只是简单的来了解一下pika的设计的思路，方便以后在使用过程中加快对问题的诊断。")]),e._v(" "),n("h5",{attrs:{id:"pika设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pika设计"}},[e._v("#")]),e._v(" pika设计")]),e._v(" "),n("p",[e._v("pika在设计的时候支持了两种运行模式，即经典模式和"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[e._v("分布式"),n("OutboundLink")],1),e._v("模式。")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("模式")]),e._v(" "),n("th",[e._v("原理")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("经典模式")]),e._v(" "),n("td",[e._v("即一主多从模式，安装pika实例维度，即1个pika实例的数据可以被多个从实例数据同步。")])]),e._v(" "),n("tr",[n("td",[e._v("分布式模式")]),e._v(" "),n("td",[e._v("即用户的数据集合称为table，将table切分成多个分片，每个分片称为slot，对于某个key的数据是由哈希算法计算来决定属于哪个slot，将所有slots及其副本按照一定策略分散到所有的pika实例中，每个pika实例有一部分的主slot和一部分从slot，主从的维度为slot。")])])])]),e._v(" "),n("p",[e._v("官网原理图如下")]),e._v(" "),n("p",[e._v("经典模式")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/fbb32ba27ac84f57901672ef4d2967ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"在这里插入图片描述"}})]),e._v(" "),n("p",[e._v("分布式模式"),n("br"),e._v(" "),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/ed53f30617f741429ee6c1308bfa4a34.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"在这里插入图片描述"}})]),e._v(" "),n("p",[e._v("从原理图中，也可以清晰的看出经典模式以实例为维度，分布式模式以slot为维度。")]),e._v(" "),n("h6",{attrs:{id:"pika启动流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pika启动流程"}},[e._v("#")]),e._v(" pika启动流程")]),e._v(" "),n("p",[e._v("基于pika-3.4.0版本的代码结构，其中pika引用了四个第三方的库，分别如下：")]),e._v(" "),n("ol",[n("li",[e._v("Blackwidow，由piak自行维护的基于rocksdb的存储管理，所有pika的数据操作都会通过blackwidow的封装最终落入rocksdb。")]),e._v(" "),n("li",[e._v("Glog，日志库，用于pika项目输入不同等级的日志。")]),e._v(" "),n("li",[e._v("Pink，由pika自行维护的事件驱动框架，封装了redis协议的解析分发功能，并提供回调函数进行处理。")]),e._v(" "),n("li",[e._v("Slash，一些处理工具函数，例如同步的或者数据类型的工具函数。")])]),e._v(" "),n("p",[e._v("启动流程中最主要的几个函数如下：")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('int main(int argc, char *argv[]) {\n  ...\n  LOG(INFO) << "Server at: " << path;\n  g_pika_cmd_table_manager = new PikaCmdTableManager();\n  g_pika_server = new PikaServer();\n  g_pika_rm = new PikaReplicaManager();\n  g_pika_proxy = new PikaProxy();\n\n  if (g_pika_conf->daemonize()) {\n    close_std();\n  }\n\n  g_pika_proxy->Start();\n  g_pika_rm->Start();\n  g_pika_server->Start();\n  ...\n}\n\n')])])]),n("p",[e._v("分为四步，即首先初始化cmd的命令，然后初始化PikaServer，接着初始化PikaReplicaManager，最后初始化PikaProxy，主要的启动函数就是如上几步，接着就继续分析一下。")]),e._v(" "),n("h6",{attrs:{id:"pikaserver功能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pikaserver功能"}},[e._v("#")]),e._v(" PikaServer功能")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('PikaServer::PikaServer() :\n  exit_(false),\n  slot_state_(INFREE),\n  have_scheduled_crontask_(false),\n  last_check_compact_time_({0, 0}),\n  master_ip_(""),\n  master_port_(0),\n  repl_state_(PIKA_REPL_NO_CONNECT),\n  role_(PIKA_ROLE_SINGLE),\n  last_meta_sync_timestamp_(0),\n  first_meta_sync_(false),\n  loop_partition_state_machine_(false),\n  force_full_sync_(false),\n  slowlog_entry_id_(0) {\n\n  //Init server ip host\n  if (!ServerInit()) {   // 初始化监听的端口和IP\n    LOG(FATAL) << "ServerInit iotcl error";\n  }\n\n  ...\n  InitBlackwidowOptions();   // 初始化Blackwidow的参数项，主要配置rocksdb的相关参数\n\t...\n\n  // Create thread   根据配置来查看有多少的工作线程数\n  worker_num_ = std::min(g_pika_conf->thread_num(),\n                         PIKA_MAX_WORKER_THREAD_NUM);\n\n  std::set<std::string> ips;\n  if (g_pika_conf->network_interface().empty()) {\n    ips.insert("0.0.0.0");\n  } else {\n    ips.insert("127.0.0.1");\n    ips.insert(host_);\n  }\n  // We estimate the queue size    获取处理的队列的大小\n  int worker_queue_limit = g_pika_conf->maxclients() / worker_num_ + 100;\n  LOG(INFO) << "Worker queue limit is " << worker_queue_limit;\n  pika_dispatch_thread_ = new PikaDispatchThread(ips, port_, worker_num_, 3000,\n                                                 worker_queue_limit, g_pika_conf->max_conn_rbuf_size());     // 设置处理响应请求的线程池\n  pika_monitor_thread_ = new PikaMonitorThread();   // 监控的线程池\n  pika_rsync_service_ = new PikaRsyncService(g_pika_conf->db_sync_path(),\n                                             g_pika_conf->port() + kPortShiftRSync);  // 同步的线程池\n  pika_pubsub_thread_ = new pink::PubSubThread();   // 订阅发布处理线程\n  pika_auxiliary_thread_ = new PikaAuxiliaryThread();   // 心跳辅助的状态改变处理线程\n\n  pika_client_processor_ = new PikaClientProcessor(g_pika_conf->thread_pool_size(), 100000);   //  处理异步的task\n\n  pthread_rwlock_init(&state_protector_, NULL);\n  pthread_rwlock_init(&slowlog_protector_, NULL);\n}\n')])])]),n("p",[e._v("这其中初始化了大量的工作线程，来启动协同处理分别启动了6个不同的线程池或者线程来进行不同的处理工作。")]),e._v(" "),n("h6",{attrs:{id:"pikadispatchthread"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pikadispatchthread"}},[e._v("#")]),e._v(" PikaDispatchThread")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('PikaDispatchThread::PikaDispatchThread(std::set<std::string> &ips, int port, int work_num,\n                                       int cron_interval, int queue_limit, int max_conn_rbuf_size)\n    : conn_factory_(max_conn_rbuf_size),\n      handles_(this) {\n  thread_rep_ = pink::NewDispatchThread(ips, port, work_num, &conn_factory_,\n                                        cron_interval, queue_limit, &handles_);\n  thread_rep_->set_thread_name("Dispatcher");\n}\n\n...\nprivate:\n  class ClientConnFactory : public pink::ConnFactory {\n   public:\n     explicit ClientConnFactory(int max_conn_rbuf_size)\n         : max_conn_rbuf_size_(max_conn_rbuf_size) {\n     }\n     virtual std::shared_ptr<pink::PinkConn> NewPinkConn(\n        int connfd,\n        const std::string &ip_port,\n        pink::Thread* server_thread,\n        void* worker_specific_data,\n        pink::PinkEpoll* pink_epoll) const {\n       return std::static_pointer_cast<pink::PinkConn>\n         (std::make_shared<PikaClientConn>(connfd, ip_port, server_thread, pink_epoll, pink::HandleType::kAsynchronous, max_conn_rbuf_size_));\n     }\n   private:\n     int max_conn_rbuf_size_;\n    ...\n      \n\t...\n  extern ServerThread *NewDispatchThread(\n    const std::set<std::string>& ips, int port,\n    int work_num, ConnFactory* conn_factory,\n    int cron_interval, int queue_limit,\n    const ServerHandle* handle) {\n  return new DispatchThread(ips, port, work_num, conn_factory,\n                            cron_interval, queue_limit, handle);\n  ...\n    \n  ...\n  DispatchThread::DispatchThread(const std::set<std::string>& ips, int port,\n                               int work_num, ConnFactory* conn_factory,\n                               int cron_interval, int queue_limit,\n                               const ServerHandle* handle)\n      : ServerThread::ServerThread(ips, port, cron_interval, handle),\n        last_thread_(0),\n        work_num_(work_num),\n        queue_limit_(queue_limit) {\n  worker_thread_ = new WorkerThread*[work_num_];\n  for (int i = 0; i < work_num_; i++) {\n    worker_thread_[i] = new WorkerThread(conn_factory, this, queue_limit, cron_interval); // 生成多个工作线程，工作线程进来的请求通过conn_factory来进行处理\n  }\n}\n\nDispatchThread::~DispatchThread() {\n  for (int i = 0; i < work_num_; i++) {\n    delete worker_thread_[i];\n  }\n  delete[] worker_thread_;\n}\n\nint DispatchThread::StartThread() {\n  for (int i = 0; i < work_num_; i++) { // 根据设置的工作线程的数量来进行处理\n    int ret = handle_->CreateWorkerSpecificData(\n        &(worker_thread_[i]->private_data_));\n    if (ret != 0) {\n      return ret;\n    }\n\n    if (!thread_name().empty()) {\n      worker_thread_[i]->set_thread_name("WorkerThread");\n    }\n    ret = worker_thread_[i]->StartThread();  // 开启每一个工作线程\n    if (ret != 0) {\n      return ret;\n    }\n  }\n  return ServerThread::StartThread();\n}\n...\n      \n')])])]),n("p",[e._v("此时会使用PikaDispatchThread的工厂方法来处理新接入的连接，并且每一个新进来的请求通过NewPinkConn来进行初始化，并接入处理。其中DispatchThread就是位于pink的库中实现的方法其中ServerThread机会在初始化的过程中进行端口IP的监听，在事件响应之后就会调用HandleNewConn方法来处理新加入的连接信息，会在处理的过程中进行一个轮训的操作来分配到工作线程，在加入事件之后就会通过新生成一个PikaClientConn来进行事件处理，当pink中的redisconn解析到了完整的命令的时候就会调用PikaClientConn的ProcessRedisCmds方法来处理（中间的逻辑有点复杂大家有兴趣可以自行查找源码阅读一下）。")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('void PikaClientConn::ProcessRedisCmds(const std::vector<pink::RedisCmdArgsType>& argvs, bool async, std::string* response) {\n  if (async) {   // 是否是后台任务\n    BgTaskArg* arg = new BgTaskArg();  // 新建一个后台任务\n    arg->redis_cmds = argvs;\n    arg->conn_ptr = std::dynamic_pointer_cast<PikaClientConn>(shared_from_this());\n    g_pika_server->ScheduleClientPool(&DoBackgroundTask, arg);  // 放入PikaClientProcessor的线程池来进行处理\n    return;\n  }\n  BatchExecRedisCmd(argvs);  // 如果不是则调用响应的线程池直接处理\n}\n\n...\nvoid PikaClientConn::BatchExecRedisCmd(const std::vector<pink::RedisCmdArgsType>& argvs) {\n  resp_num.store(argvs.size());\n  for (size_t i = 0; i < argvs.size(); ++i) {  // 根据解析的输入参数大小来处理\n    std::shared_ptr<std::string> resp_ptr = std::make_shared<std::string>();\n    resp_array.push_back(resp_ptr);\n    ExecRedisCmd(argvs[i], resp_ptr);   // 处理对应的命令\n  }\n  TryWriteResp();\n}\n...\nvoid PikaClientConn::ExecRedisCmd(const PikaCmdArgsType& argv, std::shared_ptr<std::string> resp_ptr) {\n  // get opt\n  std::string opt = argv[0];\n  slash::StringToLower(opt);\n  if (opt == kClusterPrefix) {   // 检查是否是集群名称开头\n    if (argv.size() >= 2 ) {\n      opt += argv[1];\n      slash::StringToLower(opt);\n    }\n  }\n\n  std::shared_ptr<Cmd> cmd_ptr = DoCmd(argv, opt, resp_ptr);  // 执行命令\n  // level == 0 or (cmd error) or (is_read)\n  if (g_pika_conf->consensus_level() == 0 || !cmd_ptr->res().ok() || !cmd_ptr->is_write()) {\n    *resp_ptr = std::move(cmd_ptr->res().message());\n    resp_num--;\n  }\n}\n...\n  \nstd::shared_ptr<Cmd> PikaClientConn::DoCmd(\n    const PikaCmdArgsType& argv,\n    const std::string& opt,\n    std::shared_ptr<std::string> resp_ptr) {\n  // Get command info\n  std::shared_ptr<Cmd> c_ptr = g_pika_cmd_table_manager->GetCmd(opt);   // 从命令列表中查找命令\n  if (!c_ptr) {\n    std::shared_ptr<Cmd> tmp_ptr = std::make_shared<DummyCmd>(DummyCmd());\n    tmp_ptr->res().SetRes(CmdRes::kErrOther,\n        "unknown or unsupported command \\\'" + opt + "\\"");\n    return tmp_ptr;\n  }\n  c_ptr->SetConn(std::dynamic_pointer_cast<PikaClientConn>(shared_from_this()));\n  c_ptr->SetResp(resp_ptr);\n\n  // Check authed\n  // AuthCmd will set stat_\n  if (!auth_stat_.IsAuthed(c_ptr)) {   // 检查是否认证\n    c_ptr->res().SetRes(CmdRes::kErrOther, "NOAUTH Authentication required.");\n    return c_ptr;\n  }\n\n  uint64_t start_us = 0;\n  if (g_pika_conf->slowlog_slower_than() >= 0) {\n    start_us = slash::NowMicros();\n  }\n\n  bool is_monitoring = g_pika_server->HasMonitorClients();  // 是否是监控的客户端\n  if (is_monitoring) {\n    ProcessMonitor(argv);\n  }\n\n  // Initial\n  c_ptr->Initial(argv, current_table_);  // 初始化命令信息\n  if (!c_ptr->res().ok()) {\n    return c_ptr;\n  }\n\n  g_pika_server->UpdateQueryNumAndExecCountTable(current_table_, opt, c_ptr->is_write());\n\n  // PubSub connection\n  // (P)SubscribeCmd will set is_pubsub_\n  if (this->IsPubSub()) {\n    if (opt != kCmdNameSubscribe &&\n        opt != kCmdNameUnSubscribe &&\n        opt != kCmdNamePing &&\n        opt != kCmdNamePSubscribe &&\n        opt != kCmdNamePUnSubscribe) {\n      c_ptr->res().SetRes(CmdRes::kErrOther,\n          "only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context");\n      return c_ptr;\n    }\n  }\n\n  if (g_pika_conf->consensus_level() != 0 && c_ptr->is_write()) {\n    c_ptr->SetStage(Cmd::kBinlogStage);\n  }\n  if (!g_pika_server->IsCommandSupport(opt)) {\n    c_ptr->res().SetRes(CmdRes::kErrOther,\n        "This command is not supported in current configuration");\n    return c_ptr;\n  }\n\n  if (!g_pika_server->IsTableExist(current_table_)) {\n    c_ptr->res().SetRes(CmdRes::kErrOther, "Table not found");\n    return c_ptr;\n  }\n\n  // TODO: Consider special commands, like flushall, flushdb?\n  if (c_ptr->is_write()) {\n    if (g_pika_server->IsTableBinlogIoError(current_table_)) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Writing binlog failed, maybe no space left on device");\n      return c_ptr;\n    }\n    std::vector<std::string> cur_key = c_ptr->current_key();\n    if (cur_key.empty()) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Internal ERROR");\n      return c_ptr;\n    }\n    if (g_pika_server->readonly(current_table_, cur_key.front())) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Server in read-only");\n      return c_ptr;\n    }\n    if (!g_pika_server->ConsensusCheck(current_table_, cur_key.front())) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Consensus level not match");\n    }\n  }\n\n  // Process Command   执行命令\n  c_ptr->Execute(); \n\n  if (g_pika_conf->slowlog_slower_than() >= 0) {\n    ProcessSlowlog(argv, start_us);\n  }\n  if (g_pika_conf->consensus_level() != 0 && c_ptr->is_write()) {\n    c_ptr->SetStage(Cmd::kExecuteStage);\n  }\n\n  return c_ptr;\n}\n...\n')])])]),n("p",[e._v("通过层层的调用关系最终调用到了Cmd类的Do方法，例如SetCmd的执行流程如下：")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void SetCmd::Do(std::shared_ptr<Partition> partition) {\n  rocksdb::Status s;\n  int32_t res = 1;\n  switch (condition_) {\n    case SetCmd::kXX:\n      s = partition->db()->Setxx(key_, value_, &res, sec_);  // 通过db来设置key相关的信息\n      break;\n    case SetCmd::kNX:\n      s = partition->db()->Setnx(key_, value_, &res, sec_);\n      break;\n    case SetCmd::kVX:\n      s = partition->db()->Setvx(key_, target_, value_, &success_, sec_);\n      break;\n    case SetCmd::kEXORPX:\n      s = partition->db()->Setex(key_, value_, sec_);\n      break;\n    default:\n      s = partition->db()->Set(key_, value_);\n      break;\n  }\n\n  if (s.ok() || s.IsNotFound()) {\n    if (condition_ == SetCmd::kVX) {\n      res_.AppendInteger(success_);\n    } else {\n      if (res == 1) {\n        res_.SetRes(CmdRes::kOk);\n      } else {\n        res_.AppendArrayLen(-1);;\n      }\n    }\n  } else {\n    res_.SetRes(CmdRes::kErrOther, s.ToString());\n  }\n}\n")])])]),n("p",[e._v("至此就是通过一个简单的set命令来进行的流程，当然中间省略了很多复杂的交互细节，并且跳过了pink库的一个处理流程，最终会回调在pika中的ProcessRedisCmds处理。")]),e._v(" "),n("h6",{attrs:{id:"pikaclientprocessor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pikaclientprocessor"}},[e._v("#")]),e._v(" PikaClientProcessor")]),e._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('PikaClientProcessor::PikaClientProcessor(\n    size_t worker_num, size_t max_queue_size, const std::string& name_prefix) {\n  pool_ = new pink::ThreadPool(\n      worker_num, max_queue_size, name_prefix + "Pool");   // 生成一个线程池\n  for (size_t i = 0; i < worker_num; ++i) {   \t\t\t// 根据设置的线程池数量来初始化\n    pink::BGThread* bg_thread = new pink::BGThread(max_queue_size);  // 初始化bg工作线程\n    bg_threads_.push_back(bg_thread);         \t// 保存每个线程\n    bg_thread->set_thread_name(name_prefix + "BgThread");\n  }\n}\n')])])]),n("p",[e._v("主要是生成线程池来进行后台运行。在上一节中分析的task就是交给了pool_线程池来进行数据的处理。一些协调数据同步的工作就交给了bg_threads线程池处理。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/8987955274354b59b1966e1dc87506c3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"在这里插入图片描述"}})]),e._v(" "),n("h5",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("本文主要简单的描述了有关piak的总体设计框架（参考官网架构），简单的通过PikaServer的启动过程来描述了一下基础的处理逻辑，因为这其中涉及到大量的细节故并没有详尽的去分析，并且也没有涉及到其他的功能比如slot的数据一致性保证等等细节，后续有继续再继续查阅相关内容。由于本人才疏学浅，如有错误请批评指正。")])])}),[],!1,null,null,null);n.default=a.exports}}]);